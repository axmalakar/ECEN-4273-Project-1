import sys
import os
import pygame as pg
from enum import Enum, auto
from dataclasses import dataclass

# --- Configuration ---
WIDTH, HEIGHT = 800, 600
FPS = 60
ASSETS_DIR = os.path.join(os.path.dirname(__file__), "assets")


class GameState(Enum):
    MENU = auto()
    CUTSCENE = auto()
    PLAYING = auto()
    PAUSED = auto()


@dataclass
class Player:
    pos: pg.math.Vector2
    speed: float = 200.0  # pixels per second
    image: pg.Surface = None

    def __post_init__(self):
        # create placeholder if no image provided
        if self.image is None:
            surf = pg.Surface((40, 40), pg.SRCALPHA)
            pg.draw.circle(surf, (50, 150, 250), (20, 20), 20)
            self.image = surf
        self.rect = self.image.get_rect(center=(round(self.pos.x), round(self.pos.y)))

    def handle_input(self, dt):
        keys = pg.key.get_pressed()
        move = pg.math.Vector2(0, 0)
        if keys[pg.K_w] or keys[pg.K_UP]:
            move.y = -1
        if keys[pg.K_s] or keys[pg.K_DOWN]:
            move.y = 1
        if keys[pg.K_a] or keys[pg.K_LEFT]:
            move.x = -1
        if keys[pg.K_d] or keys[pg.K_RIGHT]:
            move.x = 1

        if move.length_squared() > 0:
            move = move.normalize()
            self.pos += move * self.speed * dt
            # clamp to screen bounds
            self.pos.x = max(self.rect.width // 2, min(WIDTH - self.rect.width // 2, self.pos.x))
            self.pos.y = max(self.rect.height // 2, min(HEIGHT - self.rect.height // 2, self.pos.y))
            self.rect.center = (round(self.pos.x), round(self.pos.y))

    def draw(self, surface):
        surface.blit(self.image, self.rect)


# --- Helpers ---
def load_image(name, colorkey=None):
    path = os.path.join(ASSETS_DIR, name)
    if not os.path.isfile(path):
        return None
    try:
        image = pg.image.load(path).convert_alpha()
        if colorkey is not None:
            image.set_colorkey(colorkey)
        return image
    except Exception as e:
        print(f"Warning: failed to load image '{path}': {e}")
        return None


# --- Cutscene System ---
@dataclass
class Slide:
    text: str
    duration: float = 3.0           # seconds before auto-advance (0 = no auto-advance)
    image_name: str | None = None   # optional image in /assets
    bg_color: tuple = (10, 10, 10)  # used if no image found

class Cutscene:
    def __init__(self, slides: list[Slide], font: pg.font.Font):
        self.slides = slides
        self.index = 0
        self.time_in_slide = 0.0
        self.font = font
        self.image_cache: dict[str, pg.Surface] = {}

    def _get_image(self, name: str | None) -> pg.Surface | None:
        if not name:
            return None
        if name not in self.image_cache:
            self.image_cache[name] = load_image(name)
        return self.image_cache[name]

    @property
    def done(self) -> bool:
        return self.index >= len(self.slides)

    def reset(self):
        self.index = 0
        self.time_in_slide = 0.0

    def handle_event(self, event):
        if self.done:
            return
        # Advance on key / click
        if event.type == pg.KEYDOWN:
            if event.key in (pg.K_SPACE, pg.K_RETURN):
                self._next()
            elif event.key == pg.K_ESCAPE:
                # Skip all
                self.index = len(self.slides)
        elif event.type == pg.MOUSEBUTTONDOWN and event.button == 1:
            self._next()

    def update(self, dt: float):
        if self.done:
            return
        self.time_in_slide += dt
        current = self.slides[self.index]
        if current.duration > 0 and self.time_in_slide >= current.duration:
            self._next()

    def _next(self):
        self.index += 1
        self.time_in_slide = 0.0

    def draw(self, surface: pg.Surface):
        if self.done:
            return
        current = self.slides[self.index]
        # Background / image
        img = self._get_image(current.image_name)
        if img:
            # scale to fit keeping aspect
            surface.fill((0, 0, 0))
            scaled = pg.transform.smoothscale(img, self._fit_inside(img.get_size(), (WIDTH, HEIGHT)))
            surface.blit(scaled, scaled.get_rect(center=(WIDTH//2, HEIGHT//2)))
        else:
            surface.fill(current.bg_color)

        # Text bubble
        bubble_rect = pg.Rect(60, HEIGHT - 180, WIDTH - 120, 120)
        bubble = pg.Surface(bubble_rect.size, pg.SRCALPHA)
        pg.draw.rect(bubble, (0, 0, 0, 160), bubble.get_rect(), border_radius=18)
        pg.draw.rect(bubble, (255, 255, 255, 220), bubble.get_rect(), width=2, border_radius=18)
        surface.blit(bubble, bubble_rect.topleft)

        # Wrap text
        self._blit_wrapped_text(surface, current.text, bubble_rect.inflate(-20, -20))

        # Prompt
        prompt = self.font.render("Space/Enter: next   â€¢   ESC: skip", True, (230, 230, 230))
        surface.blit(prompt, (WIDTH - prompt.get_width() - 14, HEIGHT - prompt.get_height() - 10))

    def _fit_inside(self, img_size, box_size):
        iw, ih = img_size
        bw, bh = box_size
        scale = min(bw / iw, bh / ih)
        return (max(1, int(iw * scale)), max(1, int(ih * scale)))

    def _blit_wrapped_text(self, surface, text, rect, line_height=26):
        words = text.split()
        lines = []
        line = ""
        while words:
            word = words.pop(0)
            test = (line + " " + word).strip()
            if self.font.size(test)[0] <= rect.width:
                line = test
            else:
                lines.append(line)
                line = word
        if line:
            lines.append(line)
        y = rect.top
        for ln in lines:
            surf = self.font.render(ln, True, (240, 240, 240))
            surface.blit(surf, (rect.left, y))
            y += line_height


def main():
    pg.init()
    screen = pg.display.set_mode((WIDTH, HEIGHT))
    pg.display.set_caption("Top-Down Casino - Prototype")
    clock = pg.time.Clock()

    # Ensure assets directory exists
    if not os.path.isdir(ASSETS_DIR):
        try:
            os.makedirs(ASSETS_DIR, exist_ok=True)
        except Exception:
            pass

    # Fonts
    font = pg.font.SysFont(None, 28)
    hud_font = pg.font.SysFont(None, 24)

    # Load player image if provided
    player_img = load_image("player.png")
    player = Player(pos=pg.math.Vector2(WIDTH // 2, HEIGHT // 2), image=player_img)

    # Define cutscene slides (customize your text/images here)
    slides = [
        Slide("Jim just lost all of his money playing blackjack", duration=3.0, image_name="Image1.png", bg_color=(20,20,35)),
        Slide("Jim is very sad because he has no money and lost his wife.", duration=0, image_name="Image2.png", bg_color=(25,18,18)),
        Slide("Help Jim overcome his fear of rejection and win hella bread.", duration=3.5, image_name="Image3.png", bg_color=(10,10,10)),
    ]
    cutscene = Cutscene(slides, font)

    # Start directly in CUTSCENE; switch to PLAYING when done
    state = GameState.CUTSCENE
    running = True

    while running:
        dt = clock.tick(FPS) / 1000.0
        for event in pg.event.get():
            if event.type == pg.QUIT:
                running = False

            # --- State-specific input ---
            if state == GameState.CUTSCENE:
                cutscene.handle_event(event)
                if cutscene.done:
                    state = GameState.PLAYING

            elif state in (GameState.PLAYING, GameState.PAUSED):
                if event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:
                    state = GameState.PAUSED if state == GameState.PLAYING else GameState.PLAYING

        # --- Update ---
        if state == GameState.CUTSCENE:
            cutscene.update(dt)
            if cutscene.done:
                state = GameState.PLAYING
        elif state == GameState.PLAYING:
            player.handle_input(dt)

        # --- Draw ---
        if state == GameState.CUTSCENE:
            cutscene.draw(screen)
        else:  # PLAYING or PAUSED
            screen.fill((30, 30, 30))
            player.draw(screen)
            hud = hud_font.render(f"State: {state.name} - WASD/Arrows to move, Esc to pause", True, (220, 220, 220))
            screen.blit(hud, (10, 10))
            if state == GameState.PAUSED:
                overlay = pg.Surface((WIDTH, HEIGHT), pg.SRCALPHA)
                overlay.fill((0, 0, 0, 140))
                screen.blit(overlay, (0, 0))
                paused = pg.font.SysFont(None, 64).render("PAUSED", True, (240, 240, 240))
                screen.blit(paused, paused.get_rect(center=(WIDTH // 2, HEIGHT // 2)))

        pg.display.flip()

    pg.quit()
    sys.exit()


if __name__ == "__main__":
    main()
